<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, shrink-to-fit=no, viewport-fit=cover">
    <title>VibeCreAI - Vibe coding + Creative + AI</title>
    <meta name="description" content="VibeCreAI combines AI technology with human creativity to build innovative games, apps, and creative solutions. Explore our AI-powered tools including Spin2Pick and upcoming creative platforms.">
    <meta name="keywords" content="AI creativity, creative AI tools, AI games, AI apps, artificial intelligence, creative technology">
    <meta name="author" content="VibeCreAI">
    <link rel="icon" type="image/png" href="images/favicon.png">

    <!-- Social Media Preview -->
    <meta property="og:title" content="VibeCreAI - Vibe coding + Creative + AI">
    <meta property="og:description" content="Explore new possibilities of creation with VibeCreAI. We combine AI technology with human creativity to build innovative games, apps, and various creative solutions.">
    <meta property="og:image" content="https://www.vibecreai.com/images/og_image.png">
    <meta property="og:url" content="https://www.vibecreai.com">
    <meta property="og:type" content="website">

    <link rel="canonical" href="https://www.vibecreai.com/">
    
    <!-- Additional SEO Meta Tags -->
    <meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1">
    <meta name="theme-color" content="#00ffff">
    <meta name="msapplication-TileColor" content="#0a0a0a">
    <meta name="application-name" content="VibeCreAI">
    
    <!-- Twitter Card Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="VibeCreAI - Vibe coding + Creative + AI">
    <meta name="twitter:description" content="Explore new possibilities of creation with VibeCreAI. We combine AI technology with human creativity to build innovative games, apps, and various creative solutions.">
    <meta name="twitter:image" content="https://www.vibecreai.com/images/og_image.png">
    <meta name="twitter:site" content="@VibeCreAI">
    
    <!-- Resource Hints for Performance -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" as="script">
    
    <!-- CRITICAL: Always start from hero page - Must be in HEAD -->
    <script>
        // Execute immediately to prevent browser scroll restoration
        (function() {
            // Remove hash from URL immediately
            if (window.location.hash) {
                history.replaceState(null, null, window.location.pathname + window.location.search);
            }
            
            // Force scroll to top immediately
            if (window.scrollTo) {
                window.scrollTo(0, 0);
            }
            
            // Set scroll position directly
            if (document.documentElement) {
                document.documentElement.scrollTop = 0;
            }
            if (document.body) {
                document.body.scrollTop = 0;
            }
            
            // Disable scroll restoration
            if ('scrollRestoration' in history) {
                history.scrollRestoration = 'manual';
            }
        })();
    </script>
    
    <!-- Structured Data (JSON-LD) -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Organization",
      "name": "VibeCreAI",
      "url": "https://vibecreai.com",
      "logo": "https://vibecreai.com/images/og_image.png",
      "description": "VibeCreAI combines AI technology with human creativity to build innovative games, apps, and creative solutions.",
      "foundingDate": "2024",
      "industry": "Artificial Intelligence, Software Development, Gaming",
      "email": "contact@vibecreai.com",
      "sameAs": [
        "https://play.google.com/store/apps/developer?id=VibeCreAI"
      ],
      "hasOfferCatalog": {
        "@type": "OfferCatalog",
        "name": "AI-Powered Applications",
        "itemListElement": [
          {
            "@type": "Offer",
            "itemOffered": {
              "@type": "SoftwareApplication",
              "name": "Spin2Pick",
              "description": "AI-powered decision wheel for any purpose!",
              "operatingSystem": ["Web", "Android"],
              "applicationCategory": "EducationApplication",
              "downloadUrl": "https://play.google.com/store/apps/details?id=com.vibecreai.spin2pick"
            }
          }
        ]
      }
    }
    </script>
    <!-- CSS Files -->
    <link rel="stylesheet" href="styles/base.css">
    <link rel="stylesheet" href="styles/themes.css">
    <link rel="stylesheet" href="styles/animations.css">
    <link rel="stylesheet" href="styles/components.css">
    <link rel="stylesheet" href="styles/responsive.css">

</head>
<body>
    <!-- IMMEDIATE SCROLL RESET - Execute before any content loads -->
    <script>
        // Force immediate scroll to top - this runs before DOM elements load
        window.scrollTo(0, 0);
        document.documentElement.scrollTop = 0;
        if (document.body) document.body.scrollTop = 0;
        
        // Disable any scroll restoration from browser
        if ('scrollRestoration' in history) {
            history.scrollRestoration = 'manual';
        }
        
        // Clean URL hash
        if (window.location.hash) {
            history.replaceState(null, null, window.location.pathname + window.location.search);
        }
    </script>
    

    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loading-text">LOADING<span class="loading-cursor">_</span></div>
        <div class="loading-bar">
            <div class="loading-progress"></div>
        </div>
    </div>

    <!-- Neural Network Background Canvas -->
    <canvas id="neural-network"></canvas>
    
    <!-- Matrix Rain -->
    <canvas class="matrix-rain" id="matrix"></canvas>

    <!-- Header -->
    <header>
        <nav>
            <a href="#home" class="logo">
                <span class="logo-v">V</span>
                <span class="logo-small">IBE</span>
                <span class="logo-c">C</span>
                <span class="logo-small">RE</span>
                <span class="logo-ai">AI</span>
            </a>
            
            <button class="menu-toggle" id="menu-toggle">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <ul class="nav-links" id="nav-links">
                <li><a href="#home">HOME</a></li>
                <li><a href="#about">ABOUT</a></li>
                <li><a href="#apps">APPS</a></li>
                <li><a href="#contact">CONTACT</a></li>
            </ul>
        </nav>
    </header>

    <!-- Hero Section -->
    <section id="home" class="hero">
        <div class="hero-content">
            <h1 class="hero-title">
                <span class="glitch-text" data-text="VIBECREAI" id="logo-text-container">
                    <!-- Logo will be filled by JS with typing animation -->
                </span>
            </h1>
<p class="hero-subtitle" id="hero-subtitle"></p>
            <div class="tagline-container">
                <div class="tagline" id="tagline"></div>
                <div class="source-code-terminal" id="source-code-terminal">
                    <div class="terminal-header">
                        <div class="terminal-title">Click '/next' to navigate:</div>
                        <div class="terminal-window-controls">
                            <span class="window-control minimize" title="Minimize">−</span>
                            <span class="window-control maximize" title="Maximize">□</span>
                            <span class="window-control close" id="close-terminal" title="Close">×</span>
                        </div>
                    </div>

                    <div class="terminal-content" id="terminal-content"></div>
                </div>
            </div>
            <div class="cta-container">
                <a href="#about" class="cta-button">ABOUT</a>
                <a href="#apps" class="cta-button secondary">PROJECTS</a>
            </div>
        </div>
    </section>

    <!-- About Section -->
    <section id="about" class="about">
        <div class="container">
            <h2 class="section-title fade-in">MEET THE CREATOR</h2>
            <p class="section-subtitle fade-in">How a complete coding beginner is building the future with AI</p>
            <div class="about-grid">
                <div class="about-card fade-in perspective-container">
                    <div class="card-3d">
                        <div class="about-icon" style="background: transparent;"><img src="images/Samson_pixel.png" alt="Samson" style="width: 4.5rem; height: 4.5rem; border-radius: 50%; background: transparent; backdrop-filter: contrast(1.2) brightness(1.1);"></div>
                        <h3>SOLO DEVELOPER</h3>
                        <p>Hi! I'm Samson, founder of VibeCreAI. I have a full-time job and zero coding background, but I always dreamed of creating apps and games. Traditional programming seemed impossible to learn... until AI changed everything. Now I'm living proof that anyone with imagination can build amazing things!</p>
                    </div>
                </div>
                <div class="about-card fade-in perspective-container">
                    <div class="card-3d">
                        <div class="about-icon" style="background: transparent;"><img src="images/AI_collaboration.png" alt="AI Collaboration" style="width: 4.5rem; height: 4.5rem; border-radius: 50%; background: transparent; backdrop-filter: contrast(1.2) brightness(1.1);"></div>
                        <h3>AI COLLABORATION</h3>
                        <p>With AI as my coding partner, I went from complete beginner to app creator. No computer science degree, no years of study - just curiosity, passion, and AI assistance. Together, we're turning ideas into reality and showing that the future of creation is accessible to everyone.</p>
                    </div>
                </div>
                <div class="about-card fade-in perspective-container">
                    <div class="card-3d">
                        <div class="about-icon" style="background: transparent;"><img src="images/fun_first.png" alt="Fun First" style="width: 4.5rem; height: 4.5rem; border-radius: 50%; background: transparent; backdrop-filter: contrast(1.2) brightness(1.1);"></div>
                        <h3>FUN FIRST</h3>
                        <p>VibeCreAI is my hobby, my playground, my passion project. This isn't about becoming the next tech giant - it's about having FUN while learning and creating! Every app, every game is built with joy and the excitement of "what if we try this?" If I can do it, you can too!</p>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Apps Section -->
    <section id="apps" class="apps">
        <div class="apps-container">
            <h2 class="section-title fade-in">MY AI CREATIONS</h2>
            <p class="section-subtitle fade-in">From zero code to real apps - here's what I've built with AI!</p>
            <div class="app-showcase">
                <div class="app-card fade-in">
                    <div class="status-badge">🚀 LIVE</div>
                    <div class="app-icon-wrapper" style="background: transparent;">
                        <img src="images/spin2pick_icon.png" alt="Spin2Pick" style="width: 4.5rem; height: 4.5rem; border-radius: 50%; background: transparent; backdrop-filter: contrast(1.2) brightness(1.1);">
                    </div>
                    <h3 class="app-title">Spin2Pick</h3>
                    <p class="app-description">My first baby! 🎉 An AI-powered decision wheel that started as "what if we could make choosing fun?" Now it's helping people make decisions worldwide!</p>
                    <div class="app-buttons-container">
                        <a href="https://spin2pick-app.vercel.app/" target="_blank" class="app-button web-button">🌐 WEB APP</a>
                        <a href="https://play.google.com/store/apps/details?id=com.vibecreai.spin2pick&pli=1" target="_blank" class="app-button android-button"><img src="images/Android_robot.png" alt="Android" style="width: 1.2rem; height: 1.2rem; display: inline-block; vertical-align: middle; margin-right: 0.5rem;"> ANDROID</a>
                    </div>
                    <p class="ios-note">🍎 iOS version in the works!</p>
                </div>
                <div class="app-card fade-in">
                    <div class="status-badge">🎮 LIVE</div>
                    <div class="app-icon-wrapper" style="background: transparent;">
                        <img src="images/Vibe_Runner.png" alt="Vibe Runner" style="width: 4.5rem; height: 4.5rem; border-radius: 50%; background: transparent; backdrop-filter: contrast(1.2) brightness(1.1);">
                    </div>
                    <h3 class="app-title">VIBE RUNNER</h3>
                    <p class="app-description">Experience fast-paced endless running in a neon cyber world! Jump, slide, and navigate through geometric obstacles in this thrilling runner game. How far can you go? 🏃‍♂️</p>
                    <button class="app-button game-button" id="vibe-runner-btn">PLAY VIBE RUNNER</button>
                </div>
                <div class="app-card fade-in">
                    <div class="status-badge">🎮 LIVE</div>
                    <div class="app-icon-wrapper" style="background: transparent;">
                        <img src="images/Vibe_Survivor.png" alt="Vibe Survivor" style="width: 4.5rem; height: 4.5rem; border-radius: 50%; background: transparent; backdrop-filter: contrast(1.2) brightness(1.1);">
                    </div>
                    <h3 class="app-title">VIBE SURVIVOR</h3>
                    <p class="app-description">Survive waves of geometric enemies in this intense defense game! Use strategy and quick reflexes to outlast the neon cyber assault. Can you survive the digital apocalypse? ⚔️</p>
                    <button class="app-button game-button" id="vibe-survivor-btn">PLAY VIBE SURVIVOR</button>
                </div>
            </div>
        </div>
    </section>

    <!-- Contact Section -->
    <section id="contact" class="contact">
        <div class="contact-container">
            <h2 class="section-title fade-in">LET'S CONNECT</h2>
            <p class="contact-subtitle fade-in">Got ideas? Questions? Or just want to say hi? I'd love to hear from you!</p>
            
            <form class="contact-form fade-in" id="newsletter-form">
                <div class="form-group">
                    <input type="email" placeholder="ENTER YOUR EMAIL" required>
                    <button type="submit">JOIN THE VIBE</button>
                </div>
            </form>

            <div class="contact-info fade-in">
                <div class="contact-item">
                    <span>📧</span>
                    <a href="mailto:contact@vibecreai.com">contact@vibecreai.com</a>
                </div>
                <div class="contact-item">
                    <span>🌐</span>
                    <span>www.vibecreai.com</span>
                </div>
                <div class="contact-item">
                    <span>💻</span>
                    <a href="https://github.com/VibeCreAI/VibeCreAI-website" target="_blank" rel="noopener noreferrer">GitHub Repository</a>
                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer>
        <p>© <span id="year"></span> VIBECREAI - CREATING THE FUTURE WITH AI</p>
    </footer>
    
    
    <!-- Vibe Switcher Floating Action Button -->
    <button class="vibe-switcher" id="vibe-switcher" aria-label="Switch Vibe Theme">
        <span class="vibe-icon">VIBE</span>
        <span class="vibe-text"></span>
        <span class="vibe-tooltip">Switch Vibe Theme</span>
    </button>

    <!-- Anime.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
    
    <script>
        // Set current year
        document.getElementById('year').textContent = new Date().getFullYear();

        // Always start from hero page on refresh - Enhanced
        function ensureHeroStart() {
            // Remove any hash from URL without triggering scroll
            if (window.location.hash) {
                history.replaceState(null, null, window.location.pathname + window.location.search);
            }
            
            // Force scroll to top with multiple methods for maximum compatibility
            window.scrollTo({ top: 0, left: 0, behavior: 'auto' });
            document.documentElement.scrollTop = 0;
            document.body.scrollTop = 0;
            
            // Also reset any potential smooth scroll behavior temporarily
            document.documentElement.style.scrollBehavior = 'auto';
            document.body.style.scrollBehavior = 'auto';
            
            // Restore smooth scrolling after a brief delay
            setTimeout(() => {
                document.documentElement.style.scrollBehavior = '';
                document.body.style.scrollBehavior = '';
            }, 100);
        }
        
        // Call immediately
        ensureHeroStart();
        
        // Also call on DOMContentLoaded for extra reliability
        document.addEventListener('DOMContentLoaded', ensureHeroStart);
        
        // Handle browser back/forward navigation
        window.addEventListener('popstate', function(event) {
            // If there's no hash in the URL, ensure we're at the top
            if (!window.location.hash) {
                ensureHeroStart();
            }
        });

        // Mobile Detection
        function isMobileDevice() {
            // Check for mobile user agents
            const mobileUserAgents = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // Check for touch devices, but exclude desktop touch screens
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            
            // More specific mobile detection - combine user agent with screen size and touch
            const isSmallScreen = window.innerWidth <= 768 && window.innerHeight <= 1024;
            
            // Return true only if it's actually a mobile device
            return mobileUserAgents || (isTouchDevice && isSmallScreen);
        }


        // Loading Screen Animation
        window.addEventListener('load', () => {
            const loadingProgress = document.querySelector('.loading-progress');
            const loadingScreen = document.getElementById('loading-screen');
            
            anime({
                targets: loadingProgress,
                width: '100%',
                duration: 1500,
                easing: 'easeInOutQuad',
                complete: () => {
                    anime({
                        targets: loadingScreen,
                        opacity: 0,
                        duration: 500,
                        easing: 'easeOutQuad',
                        complete: () => {
                            loadingScreen.style.display = 'none';
                            initAnimations();
                            
                            // Apply browser-specific performance optimizations
                            if (window.PerformanceManager) {
                                window.PerformanceManager.applyBrowserOptimizations();
                            }
                        }
                    });
                }
            });
        });

        // Text Scramble Class
        class TextScramble {
            constructor(el) {
                this.el = el;
                this.chars = '!<>-_\\/[]{}—=+*^?#________';
                this.update = this.update.bind(this);
            }
            
            setText(newText) {
                const oldText = this.el.innerText;
                const length = Math.max(oldText.length, newText.length);
                const promise = new Promise((resolve) => this.resolve = resolve);
                this.queue = [];
                for (let i = 0; i < length; i++) {
                    const from = oldText[i] || '';
                    const to = newText[i] || '';
                    const start = Math.floor(Math.random() * 40);
                    const end = start + Math.floor(Math.random() * 40);
                    this.queue.push({ from, to, start, end });
                }
                cancelAnimationFrame(this.frameRequest);
                this.frame = 0;
                this.update();
                return promise;
            }
            
            update() {
                let output = '';
                let complete = 0;
                for (let i = 0, n = this.queue.length; i < n; i++) {
                    let { from, to, start, end, char } = this.queue[i];
                    if (this.frame >= end) {
                        complete++;
                        output += to;
                    } else if (this.frame >= start) {
                        if (!char || Math.random() < 0.28) {
                            char = this.randomChar();
                            this.queue[i].char = char;
                        }
                        output += `<span class="dud">${char}</span>`;
                    } else {
                        output += from;
                    }
                }
                this.el.innerHTML = output;
                if (complete === this.queue.length) {
                    this.resolve();
                } else {
                    this.frameRequest = requestAnimationFrame(this.update);
                    this.frame++;
                }
            }
            
            randomChar() {
                return this.chars[Math.floor(Math.random() * this.chars.length)];
            }
        }

        // Logo shuffle animation class
        class LogoShuffle {
            constructor(container) {
                this.container = container;
                this.logoText = "VIBECREAI";
                this.logoStructure = [
                    { text: "V", class: "title-v" },
                    { text: "IBE", class: "title-small" },
                    { text: "C", class: "title-c" },
                    { text: "RE", class: "title-small" },
                    { text: "AI", class: "title-ai" }
                ];
                this.scrambleChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?';
            }

            shuffle() {
                return new Promise((resolve) => {
                    // Clear container and set up structure
                    this.container.innerHTML = '';
                    const characterElements = [];

                    // Create the character elements
                    this.logoStructure.forEach((part) => {
                        const partSpan = document.createElement('span');
                        partSpan.className = part.class;
                        this.container.appendChild(partSpan);

                        // Create individual character spans within each part
                        for (let i = 0; i < part.text.length; i++) {
                            const charSpan = document.createElement('span');
                            charSpan.textContent = part.text[i];
                            charSpan.style.display = 'inline-block';
                            partSpan.appendChild(charSpan);
                            
                            characterElements.push({
                                element: charSpan,
                                finalChar: part.text[i],
                                isShuffling: true
                            });
                        }
                    });

                    // Start shuffling each character
                    const shuffleDuration = 1000; // Total shuffle time in ms
                    const updateInterval = 50; // Update every 50ms
                    let startTime = Date.now();
                    
                    const shuffleInterval = setInterval(() => {
                        const elapsed = Date.now() - startTime;
                        let allComplete = true;

                        characterElements.forEach((charData, index) => {
                            if (charData.isShuffling) {
                                // Calculate when this character should stop shuffling
                                const charDelay = index * 80; // Stagger by 80ms per character
                                const charDuration = 400; // Each character shuffles for 400ms
                                
                                if (elapsed < charDelay) {
                                    // Haven't started shuffling this character yet
                                    allComplete = false;
                                } else if (elapsed < charDelay + charDuration) {
                                    // Currently shuffling this character
                                    charData.element.textContent = this.getRandomChar();
                                    allComplete = false;
                                } else {
                                    // Done shuffling, show final character
                                    charData.element.textContent = charData.finalChar;
                                    charData.isShuffling = false;
                                }
                            }
                        });

                        // Stop when all characters are done
                        if (allComplete) {
                            clearInterval(shuffleInterval);
                            resolve();
                        }
                    }, updateInterval);

                    // Safety timeout
                    setTimeout(() => {
                        clearInterval(shuffleInterval);
                        // Ensure all characters show final values
                        characterElements.forEach((charData) => {
                            charData.element.textContent = charData.finalChar;
                        });
                        resolve();
                    }, shuffleDuration + 500);
                });
            }

            getRandomChar() {
                return this.scrambleChars[Math.floor(Math.random() * this.scrambleChars.length)];
            }
        }

        // True Focus Effect Function
        function applyTrueFocusEffect(element) {
            const text = element.textContent;
            
            // Define the word chunks we want to focus on
            const wordChunks = ["VIBE CODING", "CREATIVE", "AI"];
            
            // Clear the element and create focus container
            element.innerHTML = '';
            element.className += ' focus-container';
            
            // Create chunk elements
            const chunkElements = [];
            wordChunks.forEach((chunk, index) => {
                const chunkSpan = document.createElement('span');
                chunkSpan.className = 'focus-word';
                chunkSpan.textContent = chunk;
                chunkSpan.style.marginRight = '1em';
                element.appendChild(chunkSpan);
                chunkElements.push(chunkSpan);
                
                // Add space after each chunk except the last
                if (index < wordChunks.length - 1) {
                    element.appendChild(document.createTextNode(' '));
                }
            });
            
            // Create focus frame
            const focusFrame = document.createElement('div');
            focusFrame.className = 'focus-frame';
            
            // Add corner elements
            const corners = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
            corners.forEach(corner => {
                const cornerDiv = document.createElement('div');
                cornerDiv.className = `corner ${corner}`;
                focusFrame.appendChild(cornerDiv);
            });
            
            element.appendChild(focusFrame);
            
            // Animation logic
            let currentIndex = 0;
            
            function focusChunk(index) {
                // Remove focus from all chunks
                chunkElements.forEach(chunk => chunk.classList.remove('focused'));
                
                // Focus current chunk
                if (chunkElements[index]) {
                    const currentChunk = chunkElements[index];
                    currentChunk.classList.add('focused');
                    
                    // Position focus frame around current chunk
                    focusFrame.style.left = (currentChunk.offsetLeft - 8) + 'px';
                    focusFrame.style.top = (currentChunk.offsetTop - 8) + 'px';
                    focusFrame.style.width = (currentChunk.offsetWidth + 16) + 'px';
                    focusFrame.style.height = (currentChunk.offsetHeight + 16) + 'px';
                    focusFrame.classList.add('active');
                }
            }
            
            // Start the animation cycle
            function cycleFocus() {
                focusChunk(currentIndex);
                currentIndex = (currentIndex + 1) % chunkElements.length;
            }
            
            // Initial focus
            setTimeout(() => {
                cycleFocus();
                // Continue cycling every 2 seconds
                setInterval(cycleFocus, 2000);
            }, 500);
        }

        // Global Performance Management System
        const PerformanceManager = {
            neuralNetworkPaused: false,
            matrixRainPaused: false,
            
            pauseBackgroundAnimations() {
                console.log('🛑 PAUSING: Background animations for game performance...');
                
                // Force pause neural network animation
                if (neuralNetworkAnimation) {
                    cancelAnimationFrame(neuralNetworkAnimation);
                    neuralNetworkAnimation = null;
                    console.log('💀 Neural network animation stopped');
                }
                this.neuralNetworkPaused = true;
                
                // Clear and hide neural network canvas to reduce GPU load
                const neuralCanvas = document.getElementById('neural-network');
                if (neuralCanvas) {
                    const ctx = neuralCanvas.getContext('2d');
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(0, 0, neuralCanvas.width, neuralCanvas.height);
                    neuralCanvas.style.display = 'none';
                    console.log('💀 Neural canvas cleared and hidden');
                }
                
                // Force pause matrix rain animation
                if (matrixInterval) {
                    clearInterval(matrixInterval);
                    matrixInterval = null;
                    console.log('💀 Matrix rain animation stopped');
                }
                this.matrixRainPaused = true;
                
                // Clear and hide matrix canvas
                const matrixCanvas = document.getElementById('matrix');
                if (matrixCanvas) {
                    const ctx = matrixCanvas.getContext('2d');
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);
                    matrixCanvas.style.display = 'none';
                    console.log('💀 Matrix canvas cleared and hidden');
                }
                
                // Pause tagline animation
                if (window.taglineTimeout) {
                    clearTimeout(window.taglineTimeout);
                    window.taglineTimeout = null;
                    console.log('💀 Tagline animation stopped');
                }
                
                // Pause particle system
                if (particleInterval) {
                    clearInterval(particleInterval);
                    particleInterval = null;
                    console.log('💀 Particle system stopped');
                }
                
                console.log('✅ Background animations paused successfully');
            },
            
            resumeBackgroundAnimations() {
                console.log('Resuming background animations');
                
                // Resume neural network animation
                if (this.neuralNetworkPaused && typeof initNeuralNetwork === 'function') {
                    this.neuralNetworkPaused = false;
                    
                    // Restart neural network with current state
                    const neuralCanvas = document.getElementById('neural-network');
                    if (neuralCanvas) {
                        // Re-initialize neural network animation
                        initNeuralNetwork();
                    }
                }
                
                // Resume matrix rain animation
                if (this.matrixRainPaused && typeof initMatrixRain === 'function') {
                    this.matrixRainPaused = false;
                    
                    // Restart matrix rain with current state
                    const matrixCanvas = document.getElementById('matrix');
                    if (matrixCanvas) {
                        // Re-initialize matrix rain
                        initMatrixRain();
                    }
                }
                
                // Resume particle system
                if (!particleInterval && typeof createParticles === 'function') {
                    createParticles();
                    console.log('✅ Particle system resumed');
                }
            },
            
            // Browser detection for performance optimizations
            detectBrowser() {
                const userAgent = navigator.userAgent;
                if (userAgent.includes('Chrome') && !userAgent.includes('Edge')) {
                    return 'chrome';
                } else if (userAgent.includes('Firefox')) {
                    return 'firefox';
                } else if (userAgent.includes('Safari') && !userAgent.includes('Chrome')) {
                    return 'safari';
                }
                return 'other';
            },
            
            // Apply browser-specific optimizations
            applyBrowserOptimizations() {
                const browser = this.detectBrowser();
                
                if (browser === 'chrome') {
                    // Chrome-specific optimizations
                    console.log('Applying Chrome performance optimizations');
                    
                    // Suggest hardware acceleration
                    const style = document.createElement('style');
                    style.textContent = `
                        #neural-network, #matrix, #survivor-canvas {
                            transform: translateZ(0);
                            -webkit-transform: translateZ(0);
                            will-change: transform;
                        }
                    `;
                    document.head.appendChild(style);
                }
            },
            
            // Memory optimization suggestions
            optimizeMemory() {
                // Force garbage collection hint (if available)
                if (window.gc && typeof window.gc === 'function') {
                    try {
                        window.gc();
                    } catch (e) {
                        // Ignore if gc is not available
                    }
                }
                
                // Clear any unused canvas data
                const canvases = document.querySelectorAll('canvas');
                canvases.forEach(canvas => {
                    if (canvas.id !== 'survivor-canvas' && canvas.id !== 'neural-network' && canvas.id !== 'matrix') {
                        const ctx = canvas.getContext('2d');
                        if (ctx) {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                        }
                    }
                });
            }
        };
        
        // Make PerformanceManager globally accessible
        window.PerformanceManager = PerformanceManager;
        
        // Initialize all animations
        function initAnimations() {
            // Hero title drop-down animation with logo shuffle - start immediately
            anime({
                targets: '.hero-title',
                opacity: [0, 1],
                translateY: [-100, 0],
                duration: 1200,
                easing: 'easeOutExpo',
                delay: 0, // Start immediately
                complete: () => {
                    // Logo shuffle starts immediately with title animation
                }
            });

            // Start logo shuffle animation immediately
            const logoContainer = document.getElementById('logo-text-container');
            if (logoContainer) {
                // Clear the container to ensure clean start
                logoContainer.innerHTML = '';
                
                const logoShuffle = new LogoShuffle(logoContainer);
                logoShuffle.shuffle();
            }

            // Hero subtitle shuffle animation with True Focus effect - start immediately
            const subtitle = document.getElementById('hero-subtitle');
            if (subtitle) {
                const subtitleShuffle = new LogoShuffle(subtitle);
                subtitleShuffle.logoText = "VIBE CODING CREATIVE AI";
                subtitleShuffle.logoStructure = [
                    { text: "VIBE CODING CREATIVE AI", class: "" }
                ];
                subtitleShuffle.shuffle().then(() => {
                    // Apply True Focus effect after shuffle completes
                    applyTrueFocusEffect(subtitle);
                });
            }

            // CTA buttons animation - start immediately
            anime({
                targets: '.cta-button',
                opacity: [0, 1],
                translateY: [30, 0],
                duration: 1000,
                delay: anime.stagger(100, {start: 0}), // Start immediately
                easing: 'easeOutExpo'
            });

            // Start text scramble animation
            const taglineElement = document.getElementById('tagline');
            const taglineScramble = new TextScramble(taglineElement);
            const taglines = [
                "Building the future with AI...",
                "Solo developer + AI agents = ∞",
                "Creating fun digital experiences",
                "Vibe coding in progress...",
                "Press this to open terminal!",
                "Where creativity meets AI"
            ];
            
            let taglineCounter = 0;
            const nextTagline = () => {
                taglineScramble.setText(taglines[taglineCounter]).then(() => {
                    window.taglineTimeout = setTimeout(nextTagline, 3000);
                });
                taglineCounter = (taglineCounter + 1) % taglines.length;
            };
            window.taglineScramble = taglineScramble;
            window.nextTagline = nextTagline;
            nextTagline();
            
            // Start particle system
            createParticles();
            
            // Initialize neural network background
            initNeuralNetwork();
            
            // Initialize matrix rain
            initMatrixRain();
        }


        // Particle System
        let particleInterval;
        function createParticles() {
            const colors = ['#00ffff', '#2bb4db', '#ff00ff'];
            
            particleInterval = setInterval(() => {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * window.innerWidth + 'px';
                particle.style.top = Math.random() * window.innerHeight + 'px';
                particle.style.width = particle.style.height = Math.random() * 5 + 2 + 'px';
                particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                particle.style.borderRadius = '50%';
                particle.style.boxShadow = `0 0 10px ${particle.style.background}`;
                document.body.appendChild(particle);
                
                anime({
                    targets: particle,
                    translateX: (Math.random() - 0.5) * 200,
                    translateY: (Math.random() - 0.5) * 200,
                    scale: [0, 1, 0],
                    opacity: [0, 1, 0],
                    duration: 3000,
                    easing: 'easeOutExpo',
                    complete: () => particle.remove()
                });
            }, 300);
        }

        // Neural Network Background
        let neuralNetworkAnimation;
        function initNeuralNetwork() {
            const canvas = document.getElementById('neural-network');
            const ctx = canvas.getContext('2d');
            
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            
            resizeCanvas();
            
            const nodes = [];
            
            function createNodes() {
                nodes.length = 0; // Clear existing nodes
                
                // Calculate node count based on screen area
                // Base density: ~1 node per 10,000 pixels (adjustable)
                const screenArea = canvas.width * canvas.height;
                const baseDensity = 10000; // pixels per node
                const nodeCount = Math.floor(screenArea / baseDensity);
                
                // Set reasonable bounds (minimum 30, maximum 200 nodes)
                const finalNodeCount = Math.max(30, Math.min(200, nodeCount));
                
                for (let i = 0; i < finalNodeCount; i++) {
                    nodes.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        vx: (Math.random() - 0.5) * 0.3,
                        vy: (Math.random() - 0.5) * 0.3,
                        radius: Math.random() * 2 + 0.5,
                        pulseOffset: Math.random() * Math.PI * 2
                    });
                }
                
                // Optional: Log node count for debugging
                // console.log(`Neural network: ${finalNodeCount} nodes for ${canvas.width}x${canvas.height}`);
            }
            
            createNodes();
            
            let frame = 0;
            
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw connections first (behind nodes)
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const dx = nodes[i].x - nodes[j].x;
                        const dy = nodes[i].y - nodes[j].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 200) {
                            ctx.beginPath();
                            ctx.moveTo(nodes[i].x, nodes[i].y);
                            ctx.lineTo(nodes[j].x, nodes[j].y);
                            
                            const gradient = ctx.createLinearGradient(nodes[i].x, nodes[i].y, nodes[j].x, nodes[j].y);
                            const opacity = 0.65 * (1 - distance / 200);
                            gradient.addColorStop(0, `rgba(0, 255, 255, ${opacity})`);
                            gradient.addColorStop(0.5, `rgba(43, 180, 219, ${opacity * 0.8})`);
                            gradient.addColorStop(1, `rgba(0, 255, 255, ${opacity})`);
                            ctx.strokeStyle = gradient;
                            ctx.lineWidth = 1.1;
                            ctx.stroke();
                        }
                    }
                }
                
                // Update and draw nodes
                nodes.forEach((node) => {
                    node.x += node.vx;
                    node.y += node.vy;
                    
                    if (node.x < 0 || node.x > canvas.width) node.vx *= -1;
                    if (node.y < 0 || node.y > canvas.height) node.vy *= -1;
                    
                    const pulse = Math.sin(frame * 0.02 + node.pulseOffset) * 0.5 + 1;
                    
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.radius * pulse, 0, Math.PI * 2);
                    
                    const nodeGradient = ctx.createRadialGradient(
                        node.x, node.y, 0,
                        node.x, node.y, node.radius * pulse * 3
                    );
                    nodeGradient.addColorStop(0, 'rgba(0, 255, 255, 1)');
                    nodeGradient.addColorStop(0.5, 'rgba(43, 180, 219, 0.5)');
                    nodeGradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
                    
                    ctx.fillStyle = nodeGradient;
                    ctx.fill();
                });
                
                frame++;
                // Only continue animation if not paused
                if (!window.PerformanceManager || !window.PerformanceManager.neuralNetworkPaused) {
                    neuralNetworkAnimation = requestAnimationFrame(animate);
                }
            }
            
            // Resize handler for neural network
            window.neuralNetworkResize = () => {
                resizeCanvas();
                createNodes();
            };
            
            animate();
        }

        // Matrix Rain Effect
        let matrixInterval;
        function initMatrixRain() {
            const canvas = document.getElementById('matrix');
            const ctx = canvas.getContext('2d');
            
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            
            resizeCanvas();
            
            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*()';
            const fontSize = 14;
            let columns = Math.floor(canvas.width / fontSize);
            let drops = [];
            
            function initDrops() {
                columns = Math.floor(canvas.width / fontSize);
                drops = [];
                for (let i = 0; i < columns; i++) {
                    drops[i] = Math.random() * -100;
                }
            }
            
            initDrops();
            
            function draw() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#00ffff';
                ctx.font = fontSize + 'px monospace';
                
                for (let i = 0; i < drops.length; i++) {
                    const text = characters.charAt(Math.floor(Math.random() * characters.length));
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                    
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    
                    drops[i]++;
                }
            }
            
            // Resize handler for matrix rain
            window.matrixResize = () => {
                resizeCanvas();
                initDrops();
            };
            
            matrixInterval = setInterval(draw, 35);
        }

        // Mobile Menu Toggle with Enhanced Animations
        const menuToggle = document.getElementById('menu-toggle');
        const navLinks = document.getElementById('nav-links');
        let menuOpen = false;
        
        // Initialize hamburger menu with starting rotation value
        anime.set(menuToggle, { rotate: 0 });
        
        // Initialize nav links to ensure consistent starting state
        const navLinksItems = navLinks.querySelectorAll('li');
        anime.set(navLinks, {
            translateX: '100%',
            opacity: 0
        });
        anime.set(navLinksItems, {
            translateY: 0,
            opacity: 1,
            scale: 1,
            textShadow: '0 0 0px rgba(0, 255, 255, 0)'
        });
        
        menuToggle.addEventListener('click', () => {
            menuOpen = !menuOpen;
            const links = navLinks.querySelectorAll('li'); // Declare once at function scope
            
            if (menuOpen) {
                // Opening animation
                menuToggle.classList.add('active');
                navLinks.classList.add('active');
                
                // Reset nav menu to starting position before animating
                anime.set(navLinks, {
                    translateX: '100%',
                    opacity: 0
                });
                anime.set(links, {
                    translateY: 50,
                    opacity: 0,
                    scale: 0.8,
                    textShadow: '0 0 0px rgba(0, 255, 255, 0)'
                });
                
                // Animate the hamburger button transformation
                anime({
                    targets: menuToggle,
                    scale: [1, 1.1, 1],
                    rotate: '+=360',
                    duration: 600,
                    easing: 'easeOutBack'
                });
                
                // Animate the mobile menu sliding in
                anime({
                    targets: navLinks,
                    translateX: ['100%', '0%'],
                    opacity: [0, 1],
                    duration: 500,
                    easing: 'easeOutExpo'
                });
                
                // Staggered animation for nav links
                anime({
                    targets: links,
                    translateY: [50, 0],
                    opacity: [0, 1],
                    scale: [0.8, 1],
                    duration: 600,
                    delay: anime.stagger(100, {start: 200}),
                    easing: 'easeOutBack'
                });
                
                // Add pulsing glow effect to each nav item
                anime({
                    targets: links,
                    textShadow: [
                        '0 0 5px rgba(0, 255, 255, 0)',
                        '0 0 20px rgba(0, 255, 255, 0.8)',
                        '0 0 5px rgba(0, 255, 255, 0.3)'
                    ],
                    duration: 2000,
                    direction: 'alternate',
                    loop: true,
                    easing: 'easeInOutQuad',
                    delay: anime.stagger(200, {start: 800})
                });
                
            } else {
                // Closing animation
                anime({
                    targets: menuToggle,
                    scale: [1, 0.9, 1],
                    rotate: '-=360',
                    duration: 400,
                    easing: 'easeInBack',
                    complete: () => {
                        menuToggle.classList.remove('active');
                    }
                });
                
                // Animate nav links out with stagger
                anime({
                    targets: links,
                    translateY: [0, -30],
                    opacity: [1, 0],
                    scale: [1, 0.8],
                    duration: 300,
                    delay: anime.stagger(50),
                    easing: 'easeInBack'
                });
                
                // Slide out the mobile menu
                anime({
                    targets: navLinks,
                    translateX: ['0%', '100%'],
                    opacity: [1, 0],
                    duration: 400,
                    delay: 150,
                    easing: 'easeInExpo',
                    complete: () => {
                        navLinks.classList.remove('active');
                        // Reset transforms for next opening
                        anime.set(links, {
                            translateY: 0,
                            opacity: 1,
                            scale: 1,
                            textShadow: '0 0 0px rgba(0, 255, 255, 0)'
                        });
                    }
                });
            }
        });
        
        // Enhanced hover effects for hamburger menu
        menuToggle.addEventListener('mouseenter', () => {
            if (!menuOpen) {
                anime({
                    targets: menuToggle.querySelectorAll('span'),
                    scaleX: [1, 1.1],
                    duration: 200,
                    delay: anime.stagger(50),
                    easing: 'easeOutQuad'
                });
            }
        });
        
        menuToggle.addEventListener('mouseleave', () => {
            if (!menuOpen) {
                anime({
                    targets: menuToggle.querySelectorAll('span'),
                    scaleX: [1.1, 1],
                    duration: 200,
                    delay: anime.stagger(25),
                    easing: 'easeOutQuad'
                });
            }
        });

        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            if (menuOpen && !menuToggle.contains(e.target) && !navLinks.contains(e.target)) {
                // Use the same closing animation as the toggle button
                menuOpen = false;
                const links = navLinks.querySelectorAll('li');
                
                // Closing animation for hamburger button
                anime({
                    targets: menuToggle,
                    scale: [1, 0.9, 1],
                    rotate: '-=360',
                    duration: 400,
                    easing: 'easeInBack',
                    complete: () => {
                        menuToggle.classList.remove('active');
                    }
                });
                
                // Animate nav links out with stagger
                anime({
                    targets: links,
                    translateY: [0, -30],
                    opacity: [1, 0],
                    scale: [1, 0.8],
                    duration: 300,
                    delay: anime.stagger(50),
                    easing: 'easeInBack'
                });
                
                // Slide out the mobile menu
                anime({
                    targets: navLinks,
                    translateX: ['0%', '100%'],
                    opacity: [1, 0],
                    duration: 400,
                    delay: 150,
                    easing: 'easeInExpo',
                    complete: () => {
                        navLinks.classList.remove('active');
                        // Reset transforms for next opening
                        anime.set(links, {
                            translateY: 0,
                            opacity: 1,
                            scale: 1,
                            textShadow: '0 0 0px rgba(0, 255, 255, 0)'
                        });
                    }
                });
            }
        });

        // Close menu when touching outside (mobile)
        document.addEventListener('touchstart', (e) => {
            if (menuOpen && !menuToggle.contains(e.target) && !navLinks.contains(e.target)) {
                // Use the same closing animation as the toggle button
                menuOpen = false;
                const links = navLinks.querySelectorAll('li');
                
                // Closing animation for hamburger button
                anime({
                    targets: menuToggle,
                    scale: [1, 0.9, 1],
                    rotate: '-=360',
                    duration: 400,
                    easing: 'easeInBack',
                    complete: () => {
                        menuToggle.classList.remove('active');
                    }
                });
                
                // Animate nav links out with stagger
                anime({
                    targets: links,
                    translateY: [0, -30],
                    opacity: [1, 0],
                    scale: [1, 0.8],
                    duration: 300,
                    delay: anime.stagger(50),
                    easing: 'easeInBack'
                });
                
                // Slide out the mobile menu
                anime({
                    targets: navLinks,
                    translateX: ['0%', '100%'],
                    opacity: [1, 0],
                    duration: 400,
                    delay: 150,
                    easing: 'easeInExpo',
                    complete: () => {
                        navLinks.classList.remove('active');
                        // Reset transforms for next opening
                        anime.set(links, {
                            translateY: 0,
                            opacity: 1,
                            scale: 1,
                            textShadow: '0 0 0px rgba(0, 255, 255, 0)'
                        });
                    }
                });
            }
        }, {passive: true});

        // Smooth Scrolling
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                    // Close mobile menu if open and sync the state
                    if (menuOpen) {
                        menuOpen = false;
                        menuToggle.classList.remove('active');
                        navLinks.classList.remove('active');
                        
                        // Reset nav link animations immediately
                        const links = navLinks.querySelectorAll('li');
                        anime.set(links, {
                            translateY: 0,
                            opacity: 1,
                            scale: 1,
                            textShadow: '0 0 0px rgba(0, 255, 255, 0)'
                        });
                    }
                }
            });
        });

        // Scroll Animations
        const observerOptions = {
            threshold: 0.1,
            rootMargin: '0px 0px -100px 0px'
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    anime({
                        targets: entry.target,
                        opacity: [0, 1],
                        translateY: [30, 0],
                        duration: 1000,
                        easing: 'easeOutExpo'
                    });
                    entry.target.classList.add('visible');
                    observer.unobserve(entry.target);
                }
            });
        }, observerOptions);

        document.querySelectorAll('.fade-in').forEach(el => {
            observer.observe(el);
        });

        // 3D Card Tilt Effect - REMOVED
        // The 3D tilt effect has been completely removed for better UX
        
        // Load Vibe Runner Game
        const gameScript = document.createElement('script');
        gameScript.src = 'js/vibe-runner-game.js';
        gameScript.defer = true;
        document.head.appendChild(gameScript);
        
        // Load Game Manager
        const gameManagerScript = document.createElement('script');
        gameManagerScript.src = 'js/game-manager.js';
        gameManagerScript.defer = true;
        document.head.appendChild(gameManagerScript);

        // Newsletter Form
        document.getElementById('newsletter-form').addEventListener('submit', function(e) {
            e.preventDefault();
            const email = this.querySelector('input[type="email"]').value;
            const button = this.querySelector('button');
            const originalText = button.textContent;
            
            button.textContent = 'SUBSCRIBING...';
            button.disabled = true;
            
            // Simulate API call
            setTimeout(() => {
                button.textContent = 'SUBSCRIBED!';
                button.style.background = 'linear-gradient(90deg, #00ff00, #00ffcc)';
                this.querySelector('input').value = '';
                
                anime({
                    targets: button,
                    scale: [1, 1.1, 1],
                    duration: 500,
                    easing: 'easeInOutQuad'
                });
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.disabled = false;
                    button.style.background = '';
                }, 3000);
            }, 1500);
        });

        // Responsive Button Text Function
        function updateButtonTextForMobile() {
            const joinButton = document.querySelector('.form-group button[type="submit"]');
            if (joinButton) {
                if (window.innerWidth <= 480) {
                    joinButton.textContent = 'JOIN';
                } else {
                    joinButton.textContent = 'JOIN THE VIBE';
                }
            }
        }
        
        // Initialize button text on load
        updateButtonTextForMobile();
        
        // Window Resize Handler with debouncing and size range protection
        let resizeTimeout;
        let lastWidth = window.innerWidth;
        let lastHeight = window.innerHeight;
        
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            
            resizeTimeout = setTimeout(() => {
                const currentWidth = window.innerWidth;
                const currentHeight = window.innerHeight;
                
                // Define size change thresholds to prevent constant retriggering
                const widthThreshold = 100; // pixels
                const heightThreshold = 150; // pixels (larger to account for mobile address bar)
                
                const widthChange = Math.abs(currentWidth - lastWidth);
                const heightChange = Math.abs(currentHeight - lastHeight);
                
                // Only retrigger if the change is significant enough
                if (widthChange >= widthThreshold || heightChange >= heightThreshold) {
                    // Call specific resize handlers for both effects
                    if (window.neuralNetworkResize) {
                        window.neuralNetworkResize();
                    }
                    if (window.matrixResize) {
                        window.matrixResize();
                    }
                    
                    // Update responsive button text
                    updateButtonTextForMobile();
                    
                    // Update last known dimensions
                    lastWidth = currentWidth;
                    lastHeight = currentHeight;
                }
            }, 250); // Debounce delay in milliseconds
        });

        // Parallax Effect on Mouse Move - REMOVED per user request
        // document.addEventListener('mousemove', (e) => {
        //     const x = (e.clientX / window.innerWidth - 0.5) * 2;
        //     const y = (e.clientY / window.innerHeight - 0.5) * 2;
        //     
        //     anime({
        //         targets: '.hero-content',
        //         translateX: x * 10,
        //         translateY: y * 10,
        //         duration: 1000,
        //         easing: 'easeOutQuad'
        //     });
        // });

        // Add glowing effect to buttons on hover
        document.querySelectorAll('.cta-button, .app-button').forEach(button => {
            button.addEventListener('mouseenter', () => {
                anime({
                    targets: button,
                    scale: 1.05,
                    duration: 300,
                    easing: 'easeOutExpo'
                });
            });
            
            button.addEventListener('mouseleave', () => {
                anime({
                    targets: button,
                    scale: 1,
                    duration: 300,
                    easing: 'easeOutExpo'
                });
            });
        });

        // Vibe Switcher Theme Functionality
        const vibeSwitcher = document.getElementById('vibe-switcher');
        const vibeIcon = vibeSwitcher.querySelector('.vibe-icon');
        const vibeText = vibeSwitcher.querySelector('.vibe-text');
        
        const themes = [
            {
                name: 'default',
                class: '',
                text: 'VIBE',
                description: 'Default'
            },
            {
                name: 'matrix',
                class: 'theme-matrix',
                text: 'MTRX',
                description: 'Matrix'
            },
            {
                name: 'ghost',
                class: 'theme-ghost',
                text: 'GHST',
                description: 'Ghost'
            },
            {
                name: 'synthwave',
                class: 'theme-synthwave',
                text: 'SYNTH',
                description: 'Synthwave'
            }
        ];
        
        let currentThemeIndex = 0; // Always start with default theme
        
        // Apply theme function
        function applyTheme(themeIndex, animate = false) {
            const theme = themes[themeIndex];
            
            // Remove all theme classes
            themes.forEach(t => {
                if (t.class) {
                    document.body.classList.remove(t.class);
                }
            });
            
            // Apply new theme class
            if (theme.class) {
                document.body.classList.add(theme.class);
            }
            
            // Update button appearance with animation
            if (animate) {
                anime({
                    targets: vibeIcon,
                    scale: [1, 0, 1],
                    duration: 400,
                    easing: 'easeInOutQuad',
                    complete: () => {
                        vibeIcon.textContent = theme.text;
                    }
                });
            } else {
                vibeIcon.textContent = theme.text;
            }
            
            // Don't save theme to localStorage - always start fresh
            // localStorage.setItem('vibeTheme', theme.name);
            
            // Show theme change notification with anime.js
            showThemeNotification(theme.description);
        }
        
        // Show theme change notification
        function showThemeNotification(themeName) {
            // Remove existing notification if any
            const existingNotification = document.querySelector('.theme-notification');
            if (existingNotification) {
                existingNotification.remove();
            }
            
            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'theme-notification';
            notification.textContent = `${themeName} Theme Active`;
            notification.style.cssText = `
                position: fixed;
                top: 100px;
                right: 20px;
                background: rgba(0, 0, 0, 0.9);
                color: var(--primary-color);
                padding: 12px 20px;
                border: 1px solid var(--primary-color);
                border-radius: 25px;
                font-size: 0.9rem;
                font-weight: bold;
                letter-spacing: 0.1em;
                z-index: 10000;
                pointer-events: none;
                backdrop-filter: blur(10px);
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
                opacity: 0;
                transform: translateX(100px) scale(0.8);
            `;
            
            document.body.appendChild(notification);
            
            // Animate notification in
            anime({
                targets: notification,
                opacity: [0, 1],
                translateX: [100, 0],
                scale: [0.8, 1],
                duration: 400,
                easing: 'easeOutBack',
                complete: () => {
                    // Auto-hide after 2 seconds
                    setTimeout(() => {
                        anime({
                            targets: notification,
                            opacity: [1, 0],
                            translateX: [0, 100],
                            scale: [1, 0.8],
                            duration: 300,
                            easing: 'easeInBack',
                            complete: () => {
                                notification.remove();
                            }
                        });
                    }, 2000);
                }
            });
        }
        
        // Apply initial theme
        applyTheme(currentThemeIndex, false);
        
        // Vibe Switcher click handler
        vibeSwitcher.addEventListener('click', (e) => {
            e.preventDefault();
            
            // Cycle to next theme
            currentThemeIndex = (currentThemeIndex + 1) % themes.length;
            applyTheme(currentThemeIndex, true);
            
            // Button click animation
            anime({
                targets: vibeSwitcher,
                scale: [1, 0.95, 1],
                duration: 200,
                easing: 'easeOutQuad'
            });
        });
        
        // Add hover effect for vibe switcher
        vibeSwitcher.addEventListener('mouseenter', () => {
            anime({
                targets: vibeIcon,
                scale: [1, 1.05],
                duration: 200,
                easing: 'easeOutQuad'
            });
        });
        
        vibeSwitcher.addEventListener('mouseleave', () => {
            anime({
                targets: vibeIcon,
                scale: [1.05, 1],
                duration: 200,
                easing: 'easeOutQuad'
            });
        });
        
        // Source Code Terminal Dropdown Functionality
        const tagline = document.getElementById('tagline');
        const sourceTerminal = document.getElementById('source-code-terminal');
        const terminalContent = document.getElementById('terminal-content');
        const closeTerminal = document.getElementById('close-terminal');
        let terminalOpen = false;
        
        // Progressive story content sections from the footer
        const storyContent = [
            {
                title: "ABOUT THIS PROJECT",
                prompt: "cat about_project.md",
                content: `/*
 * VibeCreAI Website
 * Built with: HTML5, CSS3, JavaScript, Anime.js
 * Created by: Samson (with AI assistance)
 * 
 * This website is a testament to what's possible when
 * creativity meets AI collaboration. Every line of code
 * was written through the partnership between human
 * imagination and artificial intelligence.
 */`
            },
            {
                title: "TECH STACK",
                prompt: "cat tech_stack.js",
                content: `const techStack = {
    "frontend": ["HTML5", "CSS3", "JavaScript"],
    "animations": "Anime.js",
    "effects": [
        "Neural Network Canvas",
        "Matrix Rain Effect",
        "Particle System",
        "Custom Cursor"
    ],
    "ai_tools": ["Claude", "Cursor IDE"],
    "deployment": "GitHub Pages"
};`
            },
            {
                title: "THE VIBE CODE",
                prompt: "cat vibe_philosophy.js",
                content: `function createWithVibes() {
    const passion = "unlimited";
    const codingSkills = "learning";
    const aiAssistance = true;
    
    if (passion === "unlimited" && aiAssistance) {
        return "Amazing things are possible!";
    }
}

// Remember: You don't need to be a coding expert
// to build something amazing. You just need ideas,
// determination, and the right AI partner!`
            },
            {
                title: "GET THE SOURCE",
                prompt: "cat repository_info.md",
                content: `// This website is open source!
// Feel free to explore, learn, and create your own version.

GitHub Repository:
https://github.com/VibeCreAI/vibecreai-website

// Want to collaborate or have questions?
Email: contact@vibecreai.com`
            }
        ];
        
        let currentContentIndex = 0;
        
        // Function to get progressive story content
        function getProgressiveContent() {
            const content = storyContent[currentContentIndex];
            const displayIndex = currentContentIndex + 1; // Display 1-based index
            currentContentIndex = (currentContentIndex + 1) % storyContent.length;
            return { ...content, displayIndex };
        }
        
        // Function to go to next section via /next command
        function goToNextSection() {
            if (!terminalOpen) {
                return;
            }
            
            // Simple click animation for /next text
            anime({
                targets: '.terminal-next-text',
                scale: [1, 0.95, 1],
                duration: 150,
                easing: 'easeOutQuad'
            });
            
            // Clear current terminal content
            terminalContent.innerHTML = '';
            
            // Get next progressive content
            const contentData = getProgressiveContent();
            
            // Add terminal prompt with dynamic filename
            const promptLine = document.createElement('div');
            promptLine.className = 'terminal-line';
            promptLine.innerHTML = `<span class="terminal-prompt">$</span> ${contentData.prompt}`;
            promptLine.style.animationDelay = '0s';
            terminalContent.appendChild(promptLine);
            
            // Add empty line
            const emptyLine = document.createElement('div');
            emptyLine.className = 'terminal-line';
            emptyLine.innerHTML = '&nbsp;';
            emptyLine.style.animationDelay = '0.05s';
            terminalContent.appendChild(emptyLine);
            
            // Add section indicator
            const sectionIndicator = document.createElement('div');
            sectionIndicator.className = 'terminal-line';
            sectionIndicator.innerHTML = `<span style="color: #ffffff; font-size: 1.1em; font-weight: bold;"># ${contentData.title} (${contentData.displayIndex}/${storyContent.length})</span>`;
            sectionIndicator.style.animationDelay = '0.1s';
            terminalContent.appendChild(sectionIndicator);
            
            // Add another empty line
            const emptyLine2 = document.createElement('div');
            emptyLine2.className = 'terminal-line';
            emptyLine2.innerHTML = '&nbsp;';
            emptyLine2.style.animationDelay = '0.15s';
            terminalContent.appendChild(emptyLine2);
            
            // Split content into lines
            const lines = contentData.content.split('\n');
            
            // Display up to 12 lines of code (leaving room for prompt, empty line, section indicator, spacer, and cursor)
            const maxLines = Math.min(lines.length, 12);
            lines.slice(0, maxLines).forEach((line, index) => {
                const lineElement = document.createElement('div');
                lineElement.className = 'terminal-line';
                // Escape HTML and preserve spaces
                lineElement.textContent = line;
                lineElement.style.animationDelay = `${0.2 + (index * 0.03)}s`;
                terminalContent.appendChild(lineElement);
            });
            
            // Add empty line before cursor for better visibility
            const spacerLine = document.createElement('div');
            spacerLine.className = 'terminal-line';
            spacerLine.innerHTML = '&nbsp;';
            spacerLine.style.animationDelay = `${0.2 + (maxLines * 0.03)}s`;
            terminalContent.appendChild(spacerLine);
            
            // Add cursor at the end with /next command as plain terminal text
            const cursorLine = document.createElement('div');
            cursorLine.className = 'terminal-line';
            
            // Create prompt
            const promptElement = document.createElement('span');
            promptElement.className = 'terminal-prompt';
            promptElement.textContent = '$ ';
            
            // Create /next element with proper event handlers
            const nextElement = document.createElement('span');
            nextElement.className = 'terminal-next-text';
            nextElement.textContent = '/next';
            nextElement.onclick = function(e) {
                e.preventDefault();
                e.stopPropagation();
                goToNextSection();
            };
            nextElement.addEventListener('touchstart', function(e) {
                e.preventDefault();
                e.stopPropagation();
                goToNextSection();
            }, {passive: false});
            
            // Create cursor
            const cursorElement = document.createElement('span');
            cursorElement.className = 'terminal-cursor';
            
            // Assemble the line
            cursorLine.appendChild(promptElement);
            cursorLine.appendChild(nextElement);
            cursorLine.appendChild(cursorElement);
            cursorLine.style.animationDelay = `${0.25 + (maxLines * 0.03)}s`;
            terminalContent.appendChild(cursorLine);
            
            // Force immediate availability of click events by adding a small delay
            setTimeout(() => {
                nextElement.style.pointerEvents = 'auto';
            }, 100);
        }
        
        // Add keyboard support for /next command
        let terminalKeyBuffer = '';
        
        document.addEventListener('keydown', (e) => {
            if (!terminalOpen) return;
            
            // Add typed characters to buffer
            if (e.key.length === 1) {
                terminalKeyBuffer += e.key;
                
                // Check if user typed '/next'
                if (terminalKeyBuffer.includes('/next')) {
                    goToNextSection();
                    terminalKeyBuffer = ''; // Reset buffer
                }
                
                // Keep buffer short to prevent memory issues
                if (terminalKeyBuffer.length > 10) {
                    terminalKeyBuffer = terminalKeyBuffer.slice(-10);
                }
            }
            
            // Reset buffer on Enter or Escape
            if (e.key === 'Enter' || e.key === 'Escape') {
                terminalKeyBuffer = '';
            }
        });
        
        // Event delegation for /next clicks - this handles all /next elements
        document.addEventListener('click', function(e) {
            if (e.target && e.target.classList.contains('terminal-next-text')) {
                e.preventDefault();
                e.stopPropagation();
                goToNextSection();
            }
        });
        
        // Event delegation for touch events on /next elements
        document.addEventListener('touchstart', function(e) {
            if (e.target && e.target.classList.contains('terminal-next-text')) {
                e.preventDefault();
                e.stopPropagation();
                goToNextSection();
            }
        }, {passive: false});
        
        // Tagline click handler
        tagline.addEventListener('click', (e) => {
            e.preventDefault();
            
            if (!terminalOpen) {
                // Open terminal
                terminalOpen = true;
                sourceTerminal.classList.add('active');
                document.body.classList.add('terminal-active');
                
                // Clear and populate terminal content with random code snippet
                terminalContent.innerHTML = '';
                
                // Get progressive story content
                const contentData = getProgressiveContent();
                
                // Add terminal prompt with dynamic filename
                const promptLine = document.createElement('div');
                promptLine.className = 'terminal-line';
                promptLine.innerHTML = `<span class="terminal-prompt">$</span> ${contentData.prompt}`;
                promptLine.style.animationDelay = '0s';
                terminalContent.appendChild(promptLine);
                
                // Add empty line
                const emptyLine = document.createElement('div');
                emptyLine.className = 'terminal-line';
                emptyLine.innerHTML = '&nbsp;';
                emptyLine.style.animationDelay = '0.05s';
                terminalContent.appendChild(emptyLine);
                
                // Add section indicator
                const sectionIndicator = document.createElement('div');
                sectionIndicator.className = 'terminal-line';
                sectionIndicator.innerHTML = `<span style="color: #ffffff; font-size: 1.1em; font-weight: bold;"># ${contentData.title} (${contentData.displayIndex}/${storyContent.length})</span>`;
                sectionIndicator.style.animationDelay = '0.1s';
                terminalContent.appendChild(sectionIndicator);
                
                // Add another empty line
                const emptyLine2 = document.createElement('div');
                emptyLine2.className = 'terminal-line';
                emptyLine2.innerHTML = '&nbsp;';
                emptyLine2.style.animationDelay = '0.15s';
                terminalContent.appendChild(emptyLine2);
                
                // Split content into lines
                const lines = contentData.content.split('\n');
                
                // Display up to 12 lines of code (leaving room for prompt, empty line, section indicator, spacer, and cursor)
                const maxLines = Math.min(lines.length, 12);
                lines.slice(0, maxLines).forEach((line, index) => {
                    const lineElement = document.createElement('div');
                    lineElement.className = 'terminal-line';
                    // Escape HTML and preserve spaces
                    lineElement.textContent = line;
                    lineElement.style.animationDelay = `${0.2 + (index * 0.03)}s`;
                    terminalContent.appendChild(lineElement);
                });
                
                // Add empty line before cursor for better visibility
                const spacerLine = document.createElement('div');
                spacerLine.className = 'terminal-line';
                spacerLine.innerHTML = '&nbsp;';
                spacerLine.style.animationDelay = `${0.2 + (maxLines * 0.03)}s`;
                terminalContent.appendChild(spacerLine);
                
                // Add cursor at the end with /next command as plain terminal text
                const cursorLine = document.createElement('div');
                cursorLine.className = 'terminal-line';
                
                // Create prompt
                const promptElement = document.createElement('span');
                promptElement.className = 'terminal-prompt';
                promptElement.textContent = '$ ';
                
                // Create /next element with proper event handlers
                const nextElement = document.createElement('span');
                nextElement.className = 'terminal-next-text';
                nextElement.textContent = '/next';
                nextElement.onclick = function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    goToNextSection();
                };
                nextElement.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    goToNextSection();
                }, {passive: false});
                
                // Create cursor
                const cursorElement = document.createElement('span');
                cursorElement.className = 'terminal-cursor';
                
                // Assemble the line
                cursorLine.appendChild(promptElement);
                cursorLine.appendChild(nextElement);
                cursorLine.appendChild(cursorElement);
                cursorLine.style.animationDelay = `${0.25 + (maxLines * 0.03)}s`;
                terminalContent.appendChild(cursorLine);
                
                // Force immediate availability of click events by adding a small delay
                setTimeout(() => {
                    nextElement.style.pointerEvents = 'auto';
                }, 100);
                
                // Animate tagline click feedback
                anime({
                    targets: tagline,
                    scale: [1, 0.98, 1],
                    duration: 300,
                    easing: 'easeOutQuad'
                });
            } else {
                // Close terminal
                closeTerminalFunction();
            }
        });
        
        // Close terminal function
        function closeTerminalFunction() {
            if (terminalOpen) {
                terminalOpen = false;
                sourceTerminal.classList.remove('active');
                document.body.classList.remove('terminal-active');
            }
        }
        
        // Close button handler
        closeTerminal.addEventListener('click', (e) => {
            e.stopPropagation();
            closeTerminalFunction();
        });
        
        // Close terminal on ESC key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && terminalOpen) {
                closeTerminalFunction();
            }
        });
        
        // Prevent terminal content click from closing
        sourceTerminal.addEventListener('click', (e) => {
            e.stopPropagation();
        });
    </script>
</body>
</html>

